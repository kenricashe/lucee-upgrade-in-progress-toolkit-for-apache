#!/bin/bash

# Shared environment for upgrade-in-progress scripts
# Sets HTTPD_ROOT, HTTPD_LUCEE_ROOT, SITE_INCLUDES_404_DIR, CONF_DIR,
# IS_DEBIAN, IS_CPANEL, LUCEE_ROOT, UPG_DIR (relative to this file).

# require root
if [ "$(id -u)" != "0" ]; then
	echo "This script must be run as root or with sudo."
	exit 1
fi

# DEBUG_MODE (if not already defined)
if [ -z "${DEBUG_MODE:-}" ]; then
	DEBUG_MODE=false
fi

# IS_DEBIAN (if not already defined)
if [ -z "${IS_DEBIAN:-}" ]; then
	[ "$DEBUG_MODE" = true ] && echo "[DEBUG] Detecting distribution type..."
	if command -v a2enconf >/dev/null 2>&1; then
		[ "$DEBUG_MODE" = true ] && echo "[DEBUG] Debian-based system detected (a2enconf found)"
		IS_DEBIAN=true
	else
		[ "$DEBUG_MODE" = true ] && echo "[DEBUG] Non-Debian system (a2enconf not found)"
		IS_DEBIAN=false
	fi
fi

# IS_CPANEL (if not already defined)
if [ -z "${IS_CPANEL:-}" ]; then
	[ "$DEBUG_MODE" = true ] && echo "[DEBUG] Checking for cPanel..."
	if [ -f "/usr/local/cpanel/cpanel" ]; then
		[ "$DEBUG_MODE" = true ] && echo "[DEBUG] cPanel installation detected"
		IS_CPANEL=true
	else
		[ "$DEBUG_MODE" = true ] && echo "[DEBUG] No cPanel installation found"
		IS_CPANEL=false
	fi
fi

# HTTPD_ROOT (if not already defined)
# Prefer control commands (apache2ctl/apachectl) over direct binaries (apache2/httpd)
# as they properly set up the environment variables
if [ -z "${HTTPD_ROOT:-}" ]; then
	[ "$DEBUG_MODE" = true ] && echo "[DEBUG] Detecting HTTPD_ROOT..."
	if [ "$IS_CPANEL" = true ]; then
		[ "$DEBUG_MODE" = true ] && echo "[DEBUG] cPanel detected, using /etc/apache2"
		HTTPD_ROOT="/etc/apache2"
	else
		[ "$DEBUG_MODE" = true ] && echo "[DEBUG] Looking for Apache control command..."
		cmd=$(command -v apache2ctl || command -v apachectl || command -v httpd)
		if [ -n "$cmd" ]; then
			[ "$DEBUG_MODE" = true ] && echo "[DEBUG] Found Apache command: $cmd"
			[ "$DEBUG_MODE" = true ] && echo "[DEBUG] Running $cmd -V to get HTTPD_ROOT..."
			HTTPD_ROOT=$($cmd -V 2>/dev/null | awk -F'"' '/HTTPD_ROOT/ {print $2}')
			[ "$DEBUG_MODE" = true ] && echo "[DEBUG] HTTPD_ROOT detected as: $HTTPD_ROOT"
		else
			printf "\nERROR: No Apache controller found. Verify that Apache is installed and try again.\n"
			exit 1
		fi
	fi
fi

HTTPD_LUCEE_ROOT="${HTTPD_ROOT}/lucee-upgrade-in-progress"
SITE_INCLUDES_404_DIR="${HTTPD_LUCEE_ROOT}/site-includes-for-404"

# CONF_DIR (if any) e.g. /etc/httpd/conf.d or /etc/apache2/conf.d
if [ -z "${CONF_DIR:-}" ]; then
	if [ -d "${HTTPD_ROOT}/conf.d" ]; then
		CONF_DIR="${HTTPD_ROOT}/conf.d"
	else
		CONF_DIR=""
	fi
fi

# Abort if unsupported environment
if [ "$IS_DEBIAN" = false ] && [ -z "$CONF_DIR" ]; then
	echo "ERROR: Unsupported environment"
	echo "The two main Linux families are supported:"
	echo "Debian, Ubuntu, Pop!_OS, etc (with a2enconf)"
	echo "Fedora, Red Hat, AlmaLinux, Rocky Linux, etc (with conf.d)"
	exit 1
fi

# if sourced by deploy.sh, skip the rest of this script
SCRIPT_FILENAME=$(basename "$0")
if [ "$SCRIPT_FILENAME" = "deploy.sh" ]; then
	return 0
fi

# Determine library directory, resolving symlinks where available
LIB_PATH="${BASH_SOURCE[0]:-$0}"
if command -v readlink >/dev/null 2>&1; then
	# Prefer fully resolved path for robustness
	RESOLVED="$(readlink -f "$LIB_PATH" 2>/dev/null)"
	if [ -n "$RESOLVED" ]; then
		LIB_PATH="$RESOLVED"
	fi
fi
LIB_DIR="$(cd -P "$(dirname "$LIB_PATH")" && pwd)"

LUCEE_ROOT="$(cd "$LIB_DIR/../.." && pwd)"
LUCEE_ROOT="${LUCEE_ROOT%/}" # usually /opt/lucee
UPG_DIR="${LUCEE_ROOT}/sys/upgrade-in-progress"
SITES_FILE="${UPG_DIR}/sites-configured.txt"
EXCLUSIONS_FILE="${UPG_DIR}/site-exclusions.txt"

if [ "$SCRIPT_FILENAME" = "cpanel-simulate.sh" ]; then
	return 0
fi

press_enter_to_continue() {
	printf "\nPress Enter to continue..."
	read -r _
}

IP_ALLOW_TXT_FILE="${UPG_DIR}/ip-allow.txt"
IP_ALLOW_CONF_FILE="${HTTPD_LUCEE_ROOT}/ip-allow.conf"

create_ip_allow_txt_if_not_exist() {
	# start with localhost defaults
	if [ ! -f "${IP_ALLOW_TXT_FILE}" ]; then
		printf "# commented lines are ignored\n127.0.0.1\n::1\n" | tee "${IP_ALLOW_TXT_FILE}" >/dev/null
	fi
}

build_ip_all_conf_from_txt() {

	# Build new conf from non-empty, non-comment lines
	local TMP_CONF="$(mktemp)"
	{
		echo "# ========== DO NOT EDIT THIS FILE =========="
		echo "# Use the menu.sh script to modify this file."
		echo "# ==========================================="
		echo "<IfModule mod_setenvif.c>"
		# Read lines, strip leading/trailing whitespace, skip blanks and comments
		while IFS= read -r line; do
			# Trim leading/trailing whitespace
			trimmed="${line##*[![:space:]]}"
			trimmed="${line%%*[[:space:]]}"
			# Fallback simple trim if above results empty handling is odd
			if [ -z "$trimmed" ]; then
				trimmed="$line"
			fi
			# Skip empty lines
			if [ -z "$(echo "$trimmed" | sed -e 's/^\s\+//' -e 's/\s\+$//')" ]; then
				continue
			fi
			# Skip commented lines
			case "$trimmed" in
				\#*)
					continue
					;;
			esac
			ip="$trimmed"
			printf "\tSetEnvIf Remote_Addr \"%s\" LUCEE_UPGRADE_BYPASS=1\n" "$ip"
		done < "$IP_ALLOW_TXT_FILE"
		echo "</IfModule>"
		echo ""
	} > "$TMP_CONF"

	# Determine if there were any allow rules generated (lines with SetEnvIf)
	if grep -q "SetEnvIf Remote_Addr" "$TMP_CONF"; then
		:
	# Rebuild with header and empty block to avoid stale rules
	else
		{
			echo "# ========== DO NOT EDIT THIS FILE =========="
			echo "# Use the menu.sh script to modify this file."
			echo "# ==========================================="
			echo "<IfModule mod_setenvif.c>"
			printf "\t# No IPs currently allowed to bypass upgrade\n"
			echo "</IfModule>"
		} > "$TMP_CONF"
	fi

	mkdir -p "${HTTPD_LUCEE_ROOT}"
	cp -f --no-preserve=all "$TMP_CONF" "$IP_ALLOW_CONF_FILE"
	rm -f "$TMP_CONF"
}

# Detect which Apache controller is available to callers
# Will be one of: "apache2", "httpd", "apachectl", "apache2ctl"
# Abort if none are found
detect_apache_controller() {

	if command -v systemctl >/dev/null 2>&1; then
		if systemctl list-units --type=service | grep -q '^[[:space:]]*apache2\.service'; then
			echo "apache2"
			return 0
		elif systemctl list-units --type=service | grep -q '^[[:space:]]*httpd\.service'; then
			echo "httpd"
			return 0
		fi
	fi
	
	if command -v apachectl >/dev/null 2>&1; then
		echo "apachectl"
		return 0
	elif command -v apache2ctl >/dev/null 2>&1; then
		echo "apache2ctl"
		return 0
	fi
	
	echo ""
	echo "ERROR: No Apache controller found."
	echo "Requires httpd, apache2, apache2ctl, or apachectl"
	exit 1
}

# Detect and set global APACHE_CONTROLLER
APACHE_CONTROLLER=$(detect_apache_controller)

# Check if Apache has been configured for upgrade-in-progress
is_apache_configured() {
	if [ -f "${HTTPD_LUCEE_ROOT}/lucee-detect-upgrade.conf" ]; then
		return 0
	else
		return 1
	fi
}

echo_apache_status() {
	if command -v systemctl >/dev/null 2>&1; then
		echo ""
		echo "Apache service status:"
		echo ""
		systemctl status ${APACHE_CONTROLLER}.service --no-pager -l || true
	else
		echo ""
		echo "Check your Apache error logs for more information."
	fi
}

echo_apache_reload_failed() {
	echo ""
	echo "ERROR: Apache reload failed."
	echo ""
	echo "Apache config test result:"
	echo ""
	local CONFIG_TEST_RAN=false
	# prep return code (RC)
	local CONFIG_TEST_RC=1
	case "$APACHE_CONTROLLER" in
		httpd)
			if command -v httpd >/dev/null 2>&1; then
				CONFIG_TEST_RAN=true
				if httpd -t; then
					CONFIG_TEST_RC=0
				else
					CONFIG_TEST_RC=$?
				fi
			fi
			;;
		apache2|apache2ctl)
			if command -v apache2ctl >/dev/null 2>&1; then
				CONFIG_TEST_RAN=true
				if apache2ctl -t; then
					CONFIG_TEST_RC=0
				else
					CONFIG_TEST_RC=$?
				fi
			fi
			;;
		apachectl)
			if command -v apachectl >/dev/null 2>&1; then
				CONFIG_TEST_RAN=true
				if apachectl -t; then
					CONFIG_TEST_RC=0
				else
					CONFIG_TEST_RC=$?
				fi
			fi
			;;
		*)
			echo "No apache config test command found (apache2ctl/apachectl/httpd)."
			CONFIG_TEST_RAN=false
			;;
	esac
	# conditionally show service status or prompt to check error logs
	if [ "$CONFIG_TEST_RAN" = true ]; then
		if [ "$CONFIG_TEST_RC" -eq 0 ]; then
			echo_apache_status
		else
			:
		fi
	else
		echo_apache_status
	fi
}

# Reload Apache/httpd in a cross-distro way (uses graceful semantics where applicable)
apache_graceful_reload() {
	echo ""
	# Emit service-specific messaging based on global APACHE_CONTROLLER
	case "$APACHE_CONTROLLER" in
		apache2)
			# Try systemd first if available
			if command -v systemctl >/dev/null 2>&1 && systemctl list-units --type=service | grep -q '^[[:space:]]*apache2\.service'; then
				echo "Reloading Apache via systemctl reload apache2..."
				if ! systemctl reload apache2; then
					echo_apache_reload_failed
					return 1
				fi
				return 0
			# Fallback to apache2ctl if systemd not available
			elif command -v apache2ctl >/dev/null 2>&1; then
				echo "Reloading Apache via apache2ctl -k graceful..."
				if ! apache2ctl -k graceful; then
					echo_apache_reload_failed
					return 1
				fi
				return 0
			else
				echo_apache_reload_failed
				return 1
			fi
			;;
		apachectl)
			echo "Reloading Apache via apachectl -k graceful..."
			if ! apachectl -k graceful; then
				echo_apache_reload_failed
				return 1
			fi
			return 0
			;;
		apache2ctl)
			echo "Reloading Apache via apache2ctl -k graceful..."
			if ! apache2ctl -k graceful; then
				echo_apache_reload_failed
				return 1
			fi
			return 0
			;;
		httpd)
			# Try systemd first if available
			if command -v systemctl >/dev/null 2>&1 && systemctl list-units --type=service | grep -q '^[[:space:]]*httpd\.service'; then
				echo "Reloading Apache via systemctl reload httpd..."
				if ! systemctl reload httpd; then
					echo_apache_reload_failed
					return 1
				fi
				return 0
			# Fallback to direct httpd command if systemd not available
			elif command -v httpd >/dev/null 2>&1; then
				echo "Reloading Apache via httpd -k graceful..."
				if ! httpd -k graceful; then
					echo_apache_reload_failed
					return 1
				fi
				return 0
			# Try apachectl as last resort
			elif command -v apachectl >/dev/null 2>&1; then
				echo "Reloading Apache via apachectl -k graceful..."
				if ! apachectl -k graceful; then
					echo_apache_reload_failed
					return 1
				fi
				return 0
			else
				echo "ERROR: No httpd control command found."
				return 1
			fi
			;;
		*)
			echo "ERROR: No known Apache control command found to reload."
			return 1
			;;
	esac
}

# cPanel-specific rebuild httpd.conf + graceful restart
apache_cpanel_graceful_restart() {
	
	echo ""

	# Basic presence checks
	if [ "$IS_CPANEL" != true ]; then
		echo "ERROR: cPanel required for apache_cpanel_graceful_restart()"
		exit 1
	fi
	if [ ! -x "/scripts/rebuildhttpdconf" ] || [ ! -x "/scripts/restartsrv_httpd" ]; then
		echo "ERROR: Required cPanel scripts not found: /scripts/rebuildhttpdconf or /scripts/restartsrv_httpd"
		exit 1
	fi

	echo "Running /scripts/rebuildhttpdconf..."
	if ! /scripts/rebuildhttpdconf; then
		echo "ERROR: Rebuild failed. Check your Apache or cPanel logs."
		return 1
	fi

	echo "Running /scripts/restartsrv_httpd --graceful..."
	if ! /scripts/restartsrv_httpd --graceful; then
		echo "ERROR: Restart failed. Check your Apache or cPanel logs."
		return 1
	fi

	return 0
}

apache_reload() {
	if [ "$IS_CPANEL" = true ]; then
		apache_cpanel_graceful_restart
		return $?
	else
		apache_graceful_reload
		return $?
	fi
}
